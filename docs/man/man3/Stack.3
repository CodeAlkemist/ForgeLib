.TH "stack" 3 "Fri Jun 9 2017" "Version 0.0.1" "ForgeLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
stack \- Standard FILO stack with a traverse function to get any specific index\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Stack\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef struct \fBstack\fP \fBStack\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBstack_init\fP (\fBStack\fP *\fBstack\fP, int \fBsize\fP)"
.br
.RI "Initialises the stack with a given size\&. "
.ti -1c
.RI "void \fBstack_free\fP (\fBStack\fP *\fBstack\fP)"
.br
.RI "Frees the memory allocated to the given stack\&. "
.ti -1c
.RI "void \fBstack_resize\fP (\fBStack\fP *\fBstack\fP, int \fBsize\fP)"
.br
.RI "Resizes the stack\&. "
.ti -1c
.RI "void \fBstack_push\fP (\fBStack\fP *\fBstack\fP, int \fBdata\fP)"
.br
.RI "Pushes a value into the stack\&. "
.ti -1c
.RI "int \fBstack_pop\fP (\fBStack\fP *\fBstack\fP)"
.br
.RI "Pops a value from the stack\&. "
.ti -1c
.RI "int \fBstack_check\fP (\fBStack\fP *\fBstack\fP)"
.br
.ti -1c
.RI "int \fBgetsizeof_stack\fP (\fBStack\fP *\fBstack\fP)"
.br
.ti -1c
.RI "void \fBstack_merge\fP (\fBStack\fP *stack1, \fBStack\fP *stack2)"
.br
.RI "Merges two stacks together\&. "
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBbool\fP \fBpopc\fP"
.br
.ti -1c
.RI "int \fBtop\fP"
.br
.ti -1c
.RI "int \fBsize\fP"
.br
.ti -1c
.RI "int \fBcapacity\fP"
.br
.ti -1c
.RI "int * \fBdata\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Standard FILO stack with a traverse function to get any specific index\&. 


.PP
\fBAttention:\fP
.RS 4
stack_traverse is a bit slower than stack_pop 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "typedef struct \fBstack\fP \fBStack\fP"

.SH "Member Function Documentation"
.PP 
.SS "int getsizeof_stack (\fBStack\fP * stack)"

.PP
\fBDeprecated\fP
.RS 4
Will be removed on next major, use: 
.RE
.PP
.PP
.nf
stack\&.size
.fi
.PP
 instead 
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
stack size 
.RE
.PP

.SS "int stack_check (\fBStack\fP * stack)"

.PP
\fBDeprecated\fP
.RS 4

.RE
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "void stack_free (\fBStack\fP * stack)"

.PP
Frees the memory allocated to the given stack\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP 
.RE
.PP

.SS "void stack_init (\fBStack\fP * stack, int size)"

.PP
Initialises the stack with a given size\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP the stack to initialise 
.br
\fIsize\fP size to initialise the stack with 
.RE
.PP

.SS "void stack_merge (\fBStack\fP * stack1, \fBStack\fP * stack2)"

.PP
Merges two stacks together\&. 
.PP
\fBAttention:\fP
.RS 4
puts the output in the second stack
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstack1\fP Stack to be merged onto 
.br
\fIstack2\fP Stack to be merged into 
.RE
.PP

.SS "int stack_pop (\fBStack\fP * stack)"

.PP
Pops a value from the stack\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP the stack to pop a value from 
.RE
.PP
\fBReturns:\fP
.RS 4
the topmost data on the stack 
.RE
.PP

.SS "void stack_push (\fBStack\fP * stack, int data)"

.PP
Pushes a value into the stack\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP a stack to push the value into 
.br
\fIdata\fP any value that can be casted into an integer 
.RE
.PP

.SS "void stack_resize (\fBStack\fP * stack, int size)"

.PP
Resizes the stack\&. 
.PP
\fBWarning:\fP
.RS 4
Only mess about with this function if you know what you are doing! 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstack\fP the stack to resize 
.br
\fIsize\fP the size to go with the stack 
.RE
.PP

.SH "Field Documentation"
.PP 
.SS "int capacity"
The capacity of the stack 
.SS "int* data"
The actual data held in the stack 
.SS "\fBbool\fP popc"
To determine if it will be the first pop on the stack, only mess with if you know what you are doing 
.SS "int size"
The size of the stack 
.SS "int top"
Top of the stack index use with
.PP
.nf
stack\&.data[stack\&.top] 

.fi
.PP
 to get what's at the top of the stack 

.SH "Author"
.PP 
Generated automatically by Doxygen for ForgeLib from the source code\&.
